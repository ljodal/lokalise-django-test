#!/usr/bin/env python3

import re
import sys
from pathlib import Path
from string import Formatter
from typing import Optional

from babel.messages import Message
from babel.messages.pofile import read_po

FORMATTER = Formatter()


def parse_brace_field_names(format_str: str) -> list[str]:
    return [
        field_name
        for _, field_name, _, _ in FORMATTER.parse(format_str)
        if field_name is not None
    ]


PYTHON_FORMAT = re.compile(
    r"""
\%
    (?:\(([\w]*)\))?
    (
        [-#0\ +]?(?:\*|[\d]+)?
        (?:\.(?:\*|[\d]+))?
        [hlL]?
    )
    ([diouxXeEfFgGcrs%])
""",
    re.VERBOSE,
)


def parse_interpolate_field_names(format_str: str) -> list[str]:
    """
    Parse c-printf-style format string into list of field names.
    """

    return [m.group(0) for m in re.finditer(PYTHON_FORMAT, format_str)]


class Checker:
    """
    Check a single PO file for violations.
    """

    def __init__(self, path: Path) -> None:
        self.path = path
        with open(path) as f:
            self.catalog = read_po(f)
        self.message: Optional[Message] = None
        self.has_errors = False

    def emit_error(self, message: str) -> None:
        assert self.message is not None
        print(f"{self.path}:{self.message.lineno}: {message}")
        self.has_errors = True

    def check_is_translated(self, message: Message) -> None:

        message_strings = (
            (message.string,) if isinstance(message.string, str) else message.string
        )
        if any(string.strip() == "" for string in message_strings):
            self.emit_error("Missing translation")

    def check_missing_brace_format_flag(self, message: Message) -> None:
        """
        Check that the message has the python-brace-format flag set if they key
        appears to be using brace formatting.
        """

        message_ids = (message.id,) if isinstance(message.id, str) else message.id
        if not any(
            field_name
            for message_id in message_ids
            for field_name in parse_brace_field_names(message_id)
        ):
            return

        if "python-brace-format" not in message.flags:
            self.emit_error(
                "Translation uses brace formatting, but is not flagged with "
                "python-brace-format"
            )

    def check_brace_format(self, message: Message) -> None:
        """
        Check that any brace formatting present in the translations are also
        present in the key.
        """

        message_ids = (message.id,) if isinstance(message.id, str) else message.id
        message_strings = (
            (message.string,) if isinstance(message.string, str) else message.string
        )

        for message_id, message_string in zip(message_ids, message_strings):
            self._check_brace_format(message_id, message_string, message.flags)

    def _check_brace_format(
        self, message_id: str, message_string: str, flags: set[str]
    ) -> None:
        """
        Check that any brace formatted field names used in the message string
        is also defined in the message key.
        """

        id_field_names = {
            field_name for field_name in parse_brace_field_names(message_id)
        }

        # Extract all field names that are defined in the translation string
        string_field_names = {
            field_name for field_name in parse_brace_field_names(message_string)
        }
        if not string_field_names:
            return

        self._check_fields(id_field_names, string_field_names)

    def check_interpolate_format(self, message: Message) -> None:
        """
        Check that any brace formatting present in the translations are also
        present in the key.
        """

        message_ids = (message.id,) if isinstance(message.id, str) else message.id
        message_strings = (
            (message.string,) if isinstance(message.string, str) else message.string
        )

        for message_id, message_string in zip(message_ids, message_strings):
            self._check_interpolate_format(message_id, message_string, message.flags)

    def _check_interpolate_format(
        self, message_id: str, message_string: str, flags: set[str]
    ) -> None:

        id_field_names = {
            field_name for field_name in parse_interpolate_field_names(message_id)
        }

        # Extract all field names that are defined in the translation string
        string_field_names = {
            field_name for field_name in parse_interpolate_field_names(message_string)
        }
        if not string_field_names:
            return

        self._check_fields(id_field_names, string_field_names)

    def _check_fields(
        self, id_field_names: set[str], string_field_names: set[str]
    ) -> None:

        missing_field_names = [
            field_name
            for field_name in string_field_names
            if field_name not in id_field_names
        ]
        if len(missing_field_names) > 1:
            *rest, last = reversed(missing_field_names)
            field_names = ", ".join(f'"{field_name}"' for field_name in rest)
            self.emit_error(
                f'Field names {field_names} and "{last}" are not present in '
                f"the message id"
            )
        elif missing_field_names:
            field_name = missing_field_names[0]
            self.emit_error(
                f'Field name "{field_name}" is not present in the message id'
            )

    def check(self) -> bool:
        """
        Run all checks and return True if errors were found
        """

        checkers = list(attr for attr in dir(self) if attr.startswith("check_"))
        for message in self.catalog:
            self.message = message
            for checker in checkers:
                getattr(self, checker)(message)
            self.message = None

        return self.has_errors


def main() -> None:
    has_errors = False
    for path in Path(".").glob("project/**/*.po"):
        print(f"ğŸ” Checking {path}")
        if Checker(path).check():
            has_errors = True

    if has_errors:
        sys.exit(1)


if __name__ == "__main__":
    main()
